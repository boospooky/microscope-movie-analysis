#!/home/jparkin/anaconda3/bin/python

#Submit this script with: sbatch thefilename

#SBATCH --time=0:30:00   # walltime
#SBATCH --ntasks=1   # number of processor cores (i.e. tasks)
#SBATCH --mem-per-cpu=14G   # memory per CPU core
#SBATCH -J "prep for pad analysis 200626"   # job name
#SBATCH --mail-user=jparkin@caltech.edu   # email address
#SBATCH --mail-type=END

# LOAD MODULES, INSERT CODE, AND RUN YOUR PROGRAMS HERE
# source ~/.bashrc
import os
import traceback
import importlib
import time
import numpy as np

# load mma and acq
os.chdir('/groups/murray-biocircuits/jparkin/movies/microscope-movie-analysis')
pad_ind = os.getenv("SLURM_ARRAY_TASK_ID")
if pad_ind is None:
  pad_ind = 0
else:
  pad_ind = np.int(pad_ind)
# file_ind = 62 # 200613
# file_ind = 64 # 200627
file_ind = 63 # 200626

spec = importlib.util.spec_from_file_location("module.name", "/groups/murray-biocircuits/jparkin/movies/microscope-movie-analysis/mma.py")
mma = importlib.util.module_from_spec(spec)
spec.loader.exec_module(mma)
if True:
  with open('/groups/murray-biocircuits/jparkin/movies/microscope-movie-analysis/txt_files/unique_good_dirs_nodatadirs.txt', 'r') as f:
    lines = f.read().splitlines()
else:
  with open('/groups/murray-biocircuits/jparkin/movies/microscope-movie-analysis/txt_files/bad_files.txt', 'r') as f:
    lines = f.read().splitlines()

fn = os.path.abspath(lines[int(file_ind)])
acq = mma.Acquisition(fn)
out_dir = os.path.join(acq.super_dir,"csvs")
if not os.path.isdir(out_dir):
  os.mkdir(out_dir)
print(acq.super_dir)

# Set metadata
scale = 1#2
sigma = 2
bg_sigma = 32#32
sg_width = 9
sg_order = 1
print_img=True
bg_option='default'
overwrite=False

keys = 'acq','pad_ind','scale','sigma','bg_sigma','sg_width','sg_order','print_img','bg_option','overwrite'
vals =  acq,  pad_ind,  scale,  sigma,  bg_sigma,  sg_width,  sg_order,  print_img,  bg_option,  overwrite
procdiff_args = dict(zip(keys,vals))

im_h, im_w = acq.im_height, acq.im_width
n_f, n_c = len(acq.frame_vec), len(acq.chan_ind_list)
scratch_dir = '/central/scratchio/jparkin/tiffstacks'
scratch_dir = os.path.join(scratch_dir, acq.expname, acq.acqname)
bpl_fn = os.path.join(scratch_dir,'bpl.tiff')
rbg_fn = os.path.join(scratch_dir,'rbg.tiff')
bg_sub_fn = os.path.join(scratch_dir,'rbg_sub_bpl.tiff')
thresh_df_fn = os.path.join(acq.super_dir,'csvs','empirical_thresholds.csv')
if __name__ == '__main__':
  # Process:
  # 1. print bg_pos_list image array to tiff stack
  # 2. print raw data tiff stacks from no-fluor cell-occupied regions
  # 3. print combo bg-subtracted tiff stack
  # 4. make threshold DF
  try:
    procdiff = mma.ProcessUnorderedDiff(**procdiff_args)
    pad_helper = procdiff.pad_helper
    # Make bg_pos_list array
    bpl_arr = np.zeros((n_f, n_c, im_h, im_w),dtype=np.float32)
    for fi in acq.frame_vec:
      for ci, chan in enumerate(acq.chan_ind_list):
        bpl_arr[fi,ci,:,:] = pad_helper.load_bg_poslist_img(fi, 0, chan)
    procdiff._save_tiffstack(bpl_fn, bpl_arr)
    stack_shape = (n_f, n_c, im_h, im_w, 1)
    bg_pos_list = [2,14,28,32,9] # 200626
    n_pos = len(bg_pos_list)
    img_list = [procdiff._load_pos_stack(pos).reshape(stack_shape) for pos in bg_pos_list]
    bg_arrs = np.concatenate(img_list, axis=-1)
    procdiff._save_tiffstack(rbg_fn, bg_arrs)
    bg_arrs -= np.tile(bg_arrs[:1,...], (n_f,1,1,1,1))
    bpl_isub_arr = bpl_arr - np.tile(bpl_arr[:1,...],(n_f,1,1,1))
    bg_arrs -= np.tile(bpl_isub_arr.reshape(stack_shape), n_pos)
    procdiff._save_tiffstack(bg_sub_fn, bg_arrs)
    del bg_arrs
    del bpl_arr
    thresh_df = procdiff._make_thresh_df(bg_tiff_fn=bg_sub_fn)
    thresh_df.to_csv(thresh_df_fn)
    with open('debug.log', 'a') as f_debug:
      f_debug.write(time.asctime()+'\n')
      f_debug.write('{} wrote bpl, rbg, and threshold df'.format(fn)+'\n')
  except Exception as error:
    with open('debug.log', 'a') as f_debug:
      f_debug.write(time.asctime()+'\n')
      f_debug.write(error.__repr__()+'\n')
      f_debug.write('{} failed writing bpl, rbg, and threshold df'.format(fn)+'\n')
      f_debug.write(traceback.format_exc()+'\n')
      f_debug.write('{} failed'.format(fn)+'\n')
